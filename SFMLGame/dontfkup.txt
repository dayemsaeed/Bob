#include <Windows.h>
#include <iostream>
#include "header.h"


int main()
{

	// establish background
	sf::Texture background;
	sf::Sprite distance;

	// load image of background
	if (!background.loadFromFile("spaceBack1.png")) {
		return -1;
	}
	distance.setTexture(background);
	distance.setPosition(-900, 0);

	// platforms + ground
	sf::Texture block;
	sf::Texture * blockPtr = &block; // rectangleShapes need pointers to textures

	if (!block.loadFromFile("rocky01.png")) {
		return -1;
	}

	// lava
	sf::Texture lava;
	sf::Texture * lavaPtr = &lava; // rectangleShapes need pointers to textures

	if (!lava.loadFromFile("lava 1.png")) {
		return -1;
	}

	Platform ground[100];
	for (int i = 0; i < 100; i++) {
		if (i > 30 && i < 45) {
			ground[i].setShape(sf::Vector2f(50.f, 50.f));
			ground[i].setTexture(lavaPtr);
			ground[i].setPos(-100 + (i * 50), 650);
			ground[i].setDepth(20);
		} else if (i > 77 && i < 80) {
			ground[i].setShape(sf::Vector2f(50.f, 50.f));
			ground[i].setTexture(lavaPtr);
			ground[i].setPos(-100 + (i * 50), 650);
			ground[i].setDepth(20);
		} else {
			ground[i].setShape(sf::Vector2f(50.f, 50.f));
			ground[i].setTexture(blockPtr);
			ground[i].setPos(-100 + (i * 50), 650);
			ground[i].setDepth(0);
		}
	}

	Platform test(sf::Vector2f(0, 350), blockPtr, sf::Vector2f(400, 300), 0);
	Platform one(sf::Vector2f(700, 350), blockPtr, sf::Vector2f(400, 300), 0);
	Platform two(sf::Vector2f(500, 450), blockPtr, sf::Vector2f(250, 200), 0);
	Platform thr(sf::Vector2f(800, 250), blockPtr, sf::Vector2f(300, 400), 0);
	Platform fur(sf::Vector2f(1300, 400), blockPtr, sf::Vector2f(800, 300), 0);
	Platform fiv(sf::Vector2f(2850, 450), blockPtr, sf::Vector2f(800, 150), 0);
	Platform six(sf::Vector2f(2500, 550), blockPtr, sf::Vector2f(300, 100), 0);
	Platform sev(sf::Vector2f(2300, 450), blockPtr, sf::Vector2f(100, 100), 0);
	Platform egt(sf::Vector2f(2700, 550), blockPtr, sf::Vector2f(100, 100), 0);
	

	Platform allPlats[109];
	allPlats[0] = fur;
	for (int i = 1; i < 101; i++) {
		allPlats[i] = ground[i - 1];
	}
	allPlats[101] = one;
	allPlats[102] = two;
	allPlats[103] = thr;
	allPlats[104] = fiv;
	allPlats[105] = six;
	allPlats[106] = sev;
	allPlats[107] = egt;
	allPlats[108] = test;
	int numPlats = 109;

	// inherent attributes
	float speed = 10.0, fallingSpeed = 7.5;
	float wolfSpeed = 4.0;
	float groundHeight = 650;
	float jumpHeight = 0;
	float jumpHeightMax = 115;
	double centerX = 500;
	double centerY = 350;
	bool jumping = false; // used to check gravity
	bool collision = false;
	bool canJump = true; // used to check jumping
	enum Direction { Down, Left, Right, Up };
	
	// window stuff
	int x_coord = 0, y_coord = Right;
	sf::Vector2i source(x_coord, y_coord);
	float frameCounter = 0, switchFrame = 100, frameSpeed = 500;
	sf::Clock clock;
	sf::View gameBackground(sf::FloatRect(0, 0, 1000.f, 700.f));
	sf::RenderWindow window(sf::VideoMode(1000, 700), "Bob in Space");
	window.setVerticalSyncEnabled(true);

	// bob
	sf::Texture bobTex;
	if (!bobTex.loadFromFile("bob-sheet.png")) {
		return -1;

	}

	bobTex.setSmooth(true);
	sf::Sprite bobSprite;
	bobSprite.setTexture(bobTex);
	bobSprite.setScale(sf::Vector2f(3, 3));
	bobSprite.setPosition(200, 0);

	// wolf
	sf::Texture wolfTex;
	if (!wolfTex.loadFromFile("wolf.png")) {
		return -1;

	}

	wolfTex.setSmooth(true);
	sf::Sprite wolves[5];
	int numWolves = 5;
	for (int j = 0; j < 5; j++) {
		wolves[j].setTexture(wolfTex);
		wolves[j].setScale(sf::Vector2f(3, 3));
	}
	wolves[0].setPosition(250, 0);
	wolves[1].setPosition(550, 0);
	wolves[2].setPosition(800, 0);
	wolves[3].setPosition(1000, 0);
	wolves[4].setPosition(1500, 0);

	bool leftMove = true;
	int wolfTrack = 300;
	


	// game loop
	while (window.isOpen()) {

		sf::Event event;


		// Movement	- key pressed
		if (event.type == sf::Event::KeyPressed) {
			if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) {
				if (!(bobSprite.getPosition().x < (gameBackground.getCenter().x - 500))) { // can't move past left side of screen, 500 is offset from centerX value
					bobSprite.move(-speed, 0);
				}
				if (enemyCollisions(bobSprite, wolves, numWolves)) {
					std::cout << "Fking A " << std::endl;
				}
			}
			if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) {
				bobSprite.move(speed, 0);
				if (bobSprite.getPosition().x > centerX) { // movepast center, background moves with you
					centerX += speed;
					distance.move(speed, 0); // background moves with character
				}
			}
			if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up) && canJump == true && jumpHeight < jumpHeightMax) {
				jumping = true; // turns off gravity (magic!)
				bobSprite.move(0, -speed);
				jumpHeight += speed;
				if (jumpHeight >= jumpHeightMax) {
					canJump = false;
					jumping = false;
				}
			}
		}


		// event loop
		while (window.pollEvent(event)) {

			switch (event.type) {

			case sf::Event::Closed:
				window.close();
				break;

				// space 'jumping' is released
			case sf::Event::KeyReleased:
				jumping = false; // turns on gravity (more magic!)
			}
		}


		// gravity
		if (jumping == false && !checkCollides(bobSprite, allPlats, numPlats, Down, speed)) { // doesn't work when jumping
			bobSprite.move(0, speed);
			canJump = false;
			if (checkCollides(bobSprite, allPlats, numPlats, Down, speed)) { // can't move farther down
				jumpHeight = 0;
				canJump = true;
			}
		}

		// wolf movement 
		// bool leftMove = true;
		// int wolfTrack = 100;
		for (int z = 0; z < numWolves; z++) {
			if (leftMove == true) {
				wolves[z].move(-wolfSpeed, 0);
			}
			else {
				wolves[z].move(wolfSpeed, 0);
			}
		}
		if (leftMove == true) {
			wolfTrack -= wolfSpeed;
			if (wolfTrack <= 0) {
				leftMove = false;
			}
		}
		else {
			wolfTrack += wolfSpeed;
			if (wolfTrack >= 300) {
				leftMove = true;
			}
		}


		// wolf Gravity
		for (int h = 0; h < numWolves; h++) {
			if (!checkCollides(wolves[h], allPlats, numPlats, Down, speed)) { // doesn't work when jumping
				wolves[h].move(0, speed);
			}
		}

		// update Bob Sprite
		frameCounter += frameSpeed * clock.restart().asSeconds();
		if (frameCounter >= switchFrame) {
			frameCounter = 0;
			source.x++;
			if (source.x * 32 >= bobTex.getSize().x) {
				source.x = 0;
			}
		}
		bobSprite.setTextureRect(sf::IntRect(source.x * 32, source.y * 32, 32, 32));

		// update wolf Sprites
		if (frameCounter >= switchFrame) {
			frameCounter = 0;
			source.x++;
			if (source.x * 32 >= wolfTex.getSize().x) {
				source.x = 0;
			}
		}
		for (int l = 0; l < numWolves; l++) {
			wolves[l].setTextureRect(sf::IntRect(source.x * 32, source.y * 32, 32, 32));
		}

		window.clear();
		gameBackground.setCenter(centerX, centerY);
		window.setView(gameBackground);
		window.draw(distance);
		for (int j = 0; j < numPlats; j++) {
			allPlats[j].drawToWindow(window);
		}
		for (int w = 0; w < numWolves; w++) {
			window.draw(wolves[w]);
		}
		window.draw(bobSprite);
		window.display();

	}

	return 0;
}